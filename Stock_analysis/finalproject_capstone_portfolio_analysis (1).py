# -*- coding: utf-8 -*-
"""Finalproject_capstone_portfolio_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SU20khboXYXcZgCm_B49v4iz88cWJ2GQ
"""

from google.colab import files   #uploading listings dataset

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

pip install yfinance

pip install cufflinks

pip install chart_studio

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import yfinance as yf
import cufflinks as cf
import plotly.io as pio
pio.renderers.default = 'colab'

plt.style.use("seaborn")

pd.options.display.float_format = '{:.2f}'.format

print("All packages loaded sucessfully")

"""# **Business case**: As Financial Analyst in an Asset Management Firm that manages the Portfolios of High Net Worth Individuals (HNWI). <br><br>
Your Boss recently solicited a new Client, Mary Johnson, 65 years old. Marie recently retired after 30 Years as an independent physician. Her husband died soon and bequeathed a considerable Investment Portfolio to her. <br><br>
From 1997 until today she has been solely invested into __5 Health Care Stocks__, that are today the __most valuable__ Health Care Stocks in the US Market in terms of __Market Capitalization__. She strongly believes that it´s best to only invest into sectors where she has specific industry expertise (Health Care). She only trusts the largest and best-known companies in the market. Her Strategy has been pretty simple: Buying an __equal number of shares__ of each Stock and __reinvesting all dividends__ (assume no costs and taxes). <br> <br> 
Now that she has retired with no active work income (she needs to live from her Investment Portfolio), Mary decided to make her portfolio more suitable to the new situation. In a very first step, she agreed with your boss to sell parts of her five-Stocks Portfolio and invest into lower risk Government Bonds and high-quality Corporate Bonds.   <br> <br>

Step 1: Identify the five stocks and get the respective Stock Tickers!
"""

listings = pd.read_csv("listings_clean.csv", index_col="Symbol")

listings.info()

health = listings.loc[listings.Sector == "Health Care"].copy()

large_cap_heal = health.nlargest(n=5, columns="Market_Cap")

large_cap_heal

ticker = large_cap_heal.index.to_list

ticker()

"""Step 2: Create an appropriate Index from 1997 (hint: start with 1996-12-31) until the end of 2020 that best reflects her strategy and create a normalized Price Chart (with Base Value 100 on 1996-12-31)! """

start = "1997-01-01"
end = "2020-12-31"

stocks = yf.download(ticker(), start= start, end= end)[["Adj Close", "Close"]]

stocks.head()

stocks.tail()

weights = stocks.Close.div(stocks.Close.sum(axis=1), axis="index")

weights

ret = stocks["Adj Close"].pct_change().dropna()

# We calculate daily ret of our index

hea_index = ret.mul(weights.shift().dropna()).sum(axis=1).add(1).cumprod().mul(100)

hea_index

# We add staring weights value to 100 
hea_index[pd.to_datetime("1996-12-31")] = 100

hea_index

hea_index.sort_index(inplace=True)

hea_index.name = "Health Care"

hea_index

hea_index.plot(figsize = (12,8))
plt.title("Client's Healthcare portfolio has increased more than 9 fold from start 1997 to end 2020", fontsize=15)
plt.show()

"""Step 3: We verify the following clients statement that she made during the first meeting with your boss: "For investments periods of 6 years or longer, I never lost money with my portfolio!"

"""

annual = hea_index.resample("A", kind= "period").last().to_frame()

annual.columns = ["Price"]

annual["Return"] = np.log(annual.Price / annual.Price.shift())

annual.dropna(inplace=True)

annual

years = annual.index.size

print("No of years in index:", years)

windows = [year for year in range(years, 0, -1)]

windows

for year in windows:
  annual["{}Y".format(year)] = annual.Return.rolling(year).mean()

annual

triangle_ret_df = annual.drop(columns=["Price", "Return"])

#Plotting Triangle return matrix using heatmap visual

plt.figure(figsize=(50,40))
sns.heatmap(triangle_ret_df, annot= True, fmt= ".1%", cmap="RdYlGn",
            vmin = -0.10, vmax = 0.15, center=0)
plt.tick_params(axis= "y", labelright = True)
plt.title("Client's Healthcare portfolio has lost returns value in the 9yrs period ie..(2001 to 2009)", fontsize=15)
plt.show()

"""Step 4: Analyze and compare the performance of Mary´s Large-Cap Health Care Portfolio with other sectors for the most recent 4-years period from 2015 until 2018. Provide Client with an interactive normalized Price Chart """

indexes = pd.read_csv("sector_indexes.csv", parse_dates= ["Date"], index_col= ["Date"])

indexes.tail()

indexes["Health_Care"] = hea_index

indexes.tail()

indexes.head()

#Normalizing healthcare index

indexes.Health_Care = indexes.Health_Care.div(indexes.Health_Care[0]).mul(100)

indexes.head()

indexes.info()

import plotly.io as pio
pio.renderers.default = 'colab'

cf.set_config_file(offline=True)

indexes.iplot()

"""From the above Graph we can infer that **Health_Care** portfolio has done marignally well compared to others, but inorder to calculate the risk/retrun we need further deeper analysis."""

indexes.head()

ret_index = indexes.pct_change().dropna()

#def the function for ann risk returns

def ann_risk_return(returns_df):
  summary = returns_df.agg(["mean", "std"]).T
  summary.columns = ["Return", "Risk"]
  summary.Return = summary.Return*252
  summary.Risk = summary.Risk*np.sqrt(252)
  return summary

summary = ann_risk_return(ret_index)

summary

summary.plot(kind = "scatter", x = "Risk", y = "Return", figsize = (15,8), s= 50, fontsize = 15 )
for i in summary.index:
  plt.annotate(i, xy=(summary.loc[i,"Risk"]+0.002, summary.loc[i, "Return"]+0.002), size = 15)
plt.xlabel("ann. Risk(STD)", fontsize = 14)
plt.ylabel("ann. Return", fontsize = 14)
plt.title("Risk/Return :Inference from the below grap shows the Health_care portflio shows nominal performance", fontsize = 14)
plt.show()

rf = [0.013,0]
rf

"""![image.png](data:image/png;base64,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)"""

# We calculate the Sharpe ratio in order to have a deeper understanding on the performance of Large cap Health Sector

summary["Sharpe"] = (summary.Return - rf[0]) / summary.Risk

summary.sort_values("Sharpe", ascending= False)

"""The Large- Cap Health Sector shown the 2nd highest Sharpe Ratio (**.88**)

__Step 6:  We demonstrate to the Client that she could have improved the Sharpe Ratio of her Portfolio by adding other Sectors, without increasing the Total Risk of her Portfolio! Educate her on the Portfolio Diversification Effect!__
"""

ret_index

noa = len(ret_index.columns)
print("No of columns", noa)

nop = 50000

np.random.seed(111)
matrix = np.random.random(noa*nop).reshape(nop, noa)

weights = matrix / matrix.sum(axis= 1, keepdims = True)

weights.shape

weights

#matrix multiplcation
port_ret = ret_index.dot(weights.T)

port_ret.head()

port_summary = ann_risk_return(port_ret)

port_summary

plt.figure(figsize = (15, 9))
plt.scatter(port_summary.loc[:, "Risk"], port_summary.loc[:, "Return"],s = 20, color = "red")
plt.scatter(summary.loc[:, "Risk"], summary.loc[:, "Return"], s = 20, color = "black", marker = "D")
plt.xlabel("ann. Risk(STD)", fontsize = 14)
plt.ylabel("ann. Return", fontsize = 14)
plt.title("Risk/Return", fontsize = 14)
plt.show()

port_summary["Sharpe"] = (port_summary["Return"].sub(rf[0]))/port_summary["Risk"]

port_summary.describe()

max_shrp_ratio = port_summary.Sharpe.idxmax()

print("The portfolio ID which has max sharp ratio of 1.41 is : ", max_shrp_ratio)

msrp_p = port_summary.iloc[max_shrp_ratio]

msrp_p

summary

"""In comparsion to **Health_care** portfolio, our current diversified porfolio **46957** yeilds **2 % **more returns & offers same risk of **14 %**"""



mshrp_w = weights[max_shrp_ratio, :]
mshrp_w

new_portfolio = pd.Series(index= ret_index.columns, data = mshrp_w)

new_portfolio.to_markdown

"""__Step 7: Identify Sectors with positive Alpha and a Beta-Factor < 1. Which Sectors will be added to Client´s Portfolio?__

Calculate the following Metrics for the Sector Indexes and the Market Portfolio:

* Annualized Risk and Return (daily simple Returns)
* Sharpe Ratio
* Annualized Total Risk in Variance units
* Systematic Risk
* Unsystematic Risk
* Beta
* CAPM Return
* Alpha
"""

ret_index

indexes.head()

SP500 = pd.read_csv("SP500_TR.csv", parse_dates= ["Date"], index_col= "Date")["Close"]

SP500

SP500 = SP500.reindex(indexes.index)

ret_SP = SP500.pct_change().dropna()

ret_SP

ret_index["SP500"] = ret_SP

ret_index

#Applying Ann. function

summary_sp = ann_risk_return(ret_index)

summary_sp

summary_sp["Sharpe"] = (summary_sp["Return"].sub(rf[0]))/summary_sp["Risk"]

summary_sp["TotalRisk_var"] = np.power(summary_sp.Risk, 2)

COV = ret_index.cov()*252

COV

summary_sp["SystRisk_var"] = COV.iloc[:, -1]

summary_sp["UnsystRisk_var"] = summary_sp["TotalRisk_var"].sub(summary_sp["SystRisk_var"])

summary_sp

summary_sp["beta"] = summary_sp.SystRisk_var / summary_sp.loc["SP500", "SystRisk_var"]

summary_sp["capm_ret"] = rf[0] + (summary_sp.loc["SP500", "Return"] -rf[0]) * summary_sp.beta

summary_sp["alpha"] = summary_sp.Return -summary_sp.capm_ret

summary_sp

finalized_portfolio= summary_sp.loc[(summary_sp.alpha > 0) & (summary_sp.beta < 1)]

import plotly.figure_factory as ff

fig =  ff.create_table(summary_sp, index=True)
fig.show()

pd.options.display.float_format = '${:.2f}'.format

fig =  ff.create_table(finalized_portfolio, index=True)
fig.show()